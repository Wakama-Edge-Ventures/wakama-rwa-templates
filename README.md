# wakama-rwa-templates
<<<<<<< HEAD

Minimal Real-World-Asset (RWA) data toolkit for **Wakama.farm** to feed the Solana publisher + dashboard pipeline.

**Goal:** show how a real/agri asset (sensor reading, field batch, cooperative delivery) is turned into a **normalized JSON** that the **publisher** can upload to IPFS and reference on **Solana Devnet**.  
This repo is **not** the smart contract — it is the **data side**.

**Developed by** Wakama Edge Ventures (Wakama.farm) — **dev@wakama.farm**  
**Supported by** Solana Foundation

---

## 🧱 Structure (proposed)

```text
wakama-rwa-templates/
├─ README.md
├─ .gitignore
├─ templates/
│   ├─ sensor_record.json
│   ├─ sensor_batch.json
│   └─ mapping.csv
└─ tools/
    ├─ gen-sensor.cjs
    └─ make-receipt.cjs
```
You can create these 4 files now; they are simple but they prove the flow.

📁 1. templates/sensor_record.json
Single sensor reading, simplest possible:
```text

json
Copier le code
{
  "type": "wakama.sensor.record",
  "version": 1,
  "site": {
    "country": "CI",
    "zone": "raviart",
    "field": "bouake",
    "device": "esp32-001"
  },
  "sensor": "DHT22.tempC",
  "ts": 1730208000000,
  "value": 28.6,
  "meta": {
    "unit": "°C",
    "source": "simulated"
  }
}
```
This shows what a single on-field measure looks like.

📁 2. templates/sensor_batch.json
Batch that is compatible with the publisher (the one qu’on vient de corriger). It matches what ton src/publish.cjs --sim génère.
```text

json
Copier le code
{
  "type": "wakama.sensor.batch",
  "version": 1,
  "source": "simulated",
  "site": {
    "country": "CI",
    "zone": "raviart",
    "field": "bouake",
    "device": "esp32-001"
  },
  "ts": "2025-10-29T10:00:00.000Z",
  "readings": [
    {
      "kind": "DHT22.tempC",
      "points": [
        { "t": 1730208000000, "v": 28.3 },
        { "t": 1730208060000, "v": 28.5 }
      ]
    },
    {
      "kind": "Soil.moisturePct",
      "points": [
        { "t": 1730208000000, "v": 39.7 },
        { "t": 1730208060000, "v": 40.1 }
      ]
    }
  ],
  "meta": {
    "unitTime": "ms since epoch",
    "note": "example batch for Wakama RWA"
  }
}
```
📁 3. templates/mapping.csv
sensor_kind,metric,description,unit,source
DHT22.tempC,temperature,Air temperature,°C,field
DHT22.humidity,humidity,Air relative humidity,%,field
DS18B20.soilTempC,soil_temperature,Soil temperature,°C,field
Soil.moisturePct,soil_moisture,Soil moisture,%,field

🛠 4. tools/gen-sensor.cjs
```text

#!/usr/bin/env node
// tools/gen-sensor.cjs
const fs = require('fs');
const path = require('path');

const N = parseInt(process.argv[2] || '60', 10);
const out = process.argv[3] || 'out/sensor-batch.json';

function randn() {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
}

function genSeries(kind, base, noise, bounds) {
  const now = Date.now();
  const points = [];
  for (let i = 0; i < N; i++) {
    let v = base + noise * randn();
    v = Math.max(bounds[0], Math.min(bounds[1], v));
    points.push({ t: now - (N - 1 - i) * 60_000, v: Number(v.toFixed(2)) });
  }
  return { kind, points };
}

const batch = {
  type: 'wakama.sensor.batch',
  version: 1,
  source: 'simulated',
  site: { country: 'CI', zone: 'raviart', field: 'bouake', device: 'esp32-001' },
  ts: new Date().toISOString(),
  readings: [
    genSeries('DHT22.tempC', 28.5, 0.3, [18, 45]),
    genSeries('DHT22.humidity', 62, 1.2, [15, 98]),
    genSeries('DS18B20.soilTempC', 24, 0.25, [10, 40]),
    genSeries('Soil.moisturePct', 38, 1.0, [5, 95])
  ],
  meta: { unitTime: 'ms since epoch', note: 'generated by tools/gen-sensor.cjs' }
};

fs.mkdirSync(path.dirname(out), { recursive: true });
fs.writeFileSync(out, JSON.stringify(batch, null, 2));
console.log('Wrote', out);

🛠 5. tools/make-receipt.cjs
#!/usr/bin/env node
// tools/make-receipt.cjs
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

const src = process.argv[2];
const outDir = process.argv[3] || 'receipts';

if (!src) {
  console.error('usage: node tools/make-receipt.cjs <batch.json> [outdir]');
  process.exit(1);
}

const raw = fs.readFileSync(src, 'utf8');
const sha = crypto.createHash('sha256').update(raw).digest('hex');
const now = new Date().toISOString();

const receipt = {
  cid: 'QmPLACEHOLDER',         // will be replaced by real Pinata CID
  sha256: sha,
  tx: '',
  file: path.basename(src),
  gw: 'https://gateway.pinata.cloud/ipfs',
  source: 'simulated',
  status: 'n/a',
  slot: null,
  ts: now
};

fs.mkdirSync(outDir, { recursive: true });
const outPath = path.join(outDir, `${Date.now()}-receipt.json`);
fs.writeFileSync(outPath, JSON.stringify(receipt, null, 2));
console.log('Wrote receipt', outPath);
```


## 📤 How to publish a real RWA to Wakama Dashboard

1. Create a JSON from the templates (sensor or coop) and put it in `templates/`.
2. Make a local receipt from it:
   ```bash
   node tools/make-receipt.cjs templates/<your-file>.json
   cp receipts/*.json ../wakama-oracle-publisher/receipts/
---
© 2025 Wakama Edge Ventures (Wakama.farm) — dev@wakama.farm  
Supported by Solana Foundation
=======
Gabarits (SAFT/SAFTE, attestations RWA, YAML examples).
>>>>>>> 85a268e (chore(rwa-templates): init repo + README, LICENSE, skeleton)
